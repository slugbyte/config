#!/bin/bash
# screenshot - Take a screenshot with area selection
#
# Interactive screenshot tool for Hyprland. Freezes screen, allows
# region selection with slurp, captures with grim, copies to clipboard,
# and saves to file. Clicking on a window captures that window.
#
# Usage:
#   screenshot [label]
#
# Examples:
#   screenshot                # saves as screenshot-20240115-143022.png
#   screenshot bugfix         # saves as screenshot-20240115-143022-bugfix.png
#   screenshot "ui update"    # spaces converted to dashes

[[ "$1" == "--describe" ]] && echo "Take screenshot with interactive area selection" && exit 0

if [[ "$1" == "--help" ]]; then
    echo "Usage: screenshot [label]"
    echo ""
    echo "Take screenshot with interactive area selection."
    echo "  label   Optional suffix for filename"
    echo ""
    echo "Output: \$OMARCHY_SCREENSHOT_DIR or \$XDG_PICTURES_DIR/screenshot-*.png"
    echo "Also copies to clipboard and symlinks to 'last'."
    exit 0
fi

[[ -f ~/.config/user-dirs.dirs ]] && source ~/.config/user-dirs.dirs
OUTPUT_DIR="${OMARCHY_SCREENSHOT_DIR:-${XDG_PICTURES_DIR:-$HOME/Pictures}}"

if [[ ! -d "$OUTPUT_DIR" ]]; then
  notify-send "Screenshot directory does not exist: $OUTPUT_DIR" -u critical -t 3000
  exit 1
fi

pkill slurp && exit 0

get_rectangles() {
  local active_workspace=$(hyprctl monitors -j | jq -r '.[] | select(.focused == true) | .activeWorkspace.id')
  hyprctl monitors -j | jq -r --arg ws "$active_workspace" '.[] | select(.activeWorkspace.id == ($ws | tonumber)) | "\(.x),\(.y) \((.width / .scale) | floor)x\((.height / .scale) | floor)"'
  hyprctl clients -j | jq -r --arg ws "$active_workspace" '.[] | select(.workspace.id == ($ws | tonumber)) | "\(.at[0]),\(.at[1]) \(.size[0])x\(.size[1])"'
}

RECTS=$(get_rectangles)
wayfreeze & PID=$!
sleep .1
SELECTION=$(echo "$RECTS" | slurp 2>/dev/null)
kill $PID 2>/dev/null

# If the selction area is L * W < 20, we'll assume you were trying to select whichever
# window or output it was inside of to prevent accidental 2px snapshots
if [[ "$SELECTION" =~ ^([0-9]+),([0-9]+)[[:space:]]([0-9]+)x([0-9]+)$ ]]; then
  if (( ${BASH_REMATCH[3]} * ${BASH_REMATCH[4]} < 20 )); then
    click_x="${BASH_REMATCH[1]}"
    click_y="${BASH_REMATCH[2]}"

    while IFS= read -r rect; do
      if [[ "$rect" =~ ^([0-9]+),([0-9]+)[[:space:]]([0-9]+)x([0-9]+) ]]; then
        rect_x="${BASH_REMATCH[1]}"
        rect_y="${BASH_REMATCH[2]}"
        rect_width="${BASH_REMATCH[3]}"
        rect_height="${BASH_REMATCH[4]}"

        if (( click_x >= rect_x && click_x < rect_x+rect_width && click_y >= rect_y && click_y < rect_y+rect_height )); then
          SELECTION="${rect_x},${rect_y} ${rect_width}x${rect_height}"
          break
        fi
      fi
    done <<< "$RECTS"
  fi
fi

[ -z "$SELECTION" ] && exit 0

SCREENSHOT_PATH="$OUTPUT_DIR/screenshot-$(date +'%Y%m%d-%H%M%S')${1:+"-${1//[_ ]/-}"}.png"

grim -g "$SELECTION" "$SCREENSHOT_PATH"
wl-copy < "$SCREENSHOT_PATH"

ln -sf "$SCREENSHOT_PATH" "$OUTPUT_DIR/last"

echo $SCREENSHOT_PATH
